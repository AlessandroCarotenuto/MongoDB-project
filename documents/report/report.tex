\documentclass[a4paper,12pt]{article}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{wrapfig}
\usepackage{array}
\usepackage{color} 
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage{tcolorbox}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
\usepackage{changepage}
\addto{\captionsenglish}{\renewcommand{\refname}{}}

\begin{document}

\title{%
  Group Project Part 2 - MongoDB \\
  \large of Systems and Methods for Big
    and Unstructured Data Course \\(SMBUD)\\
    held by\\ Brambilla Marco\\ Tocchetti Andrea \\
  \vspace{5mm}
  \Large \textbf{Group 14}}
\author{Banfi Federico\\
  \texttt{10581441}
  \and
  Carotenuto Alessandro\\
  \texttt{10803080}
  \and
  Donati Riccardo\\
  \texttt{10669618}
  \and
  Mornatta Davide\\
  \texttt{10657647}
  \and
  Zancani Lea\\
  \texttt{10608972}}
\date{Academic year 2021/2022}
\maketitle
\begin{center}
  \includegraphics[width=4cm]{polilogo.png}\\
\end{center}
\newpage
\tableofcontents
\newpage
\section{Problem Specification}
\paragraph{}During the sanitary emergency due to the Covid-19 pandemic, many programs and applications developed thanks to the use of Big Data proved to be particularly effective in different settings and scenarios, such as the hospital administration, the hospitalizations organization or the analysis of data relating to various clinical cases. Among the various areas that have been supported by these technologies there is also that which concerns the tracking of populations belonging to a given geographical area and the collection of all information regarding the tests carried out and the vaccination status. \par
Our project aims to create an information system suitable for this specific use case and to do this it is necessary to design a database that allows us to store large amounts of data derived from heterogeneous sources and to carry out targeted queries useful for different purposes. The NOSQL document-based approach, known for being based on managing data saved in JSON-like documents, is the optimal one in this case and MongoDB is the open source database management software that is best suited to accomplish this task thanks to the considerable scalability guaranteed by the automatic data sharding and ease of use thanks to the dynamic schemes developed starting from the archived documents.
\section{Hypotheses}
\paragraph{} The way in which the database was structured and implemented is based on some hypotheses discussed in the design phase. \par Considering a typical scenario in which each person can interact either with people who live with him (family members or roommates) or with other people who go to meet voluntarily or not in a limited closed place (for example a gym, a public place, a restaurant, etc.) or in an open place located in a generic position, it was assumed that the infection can occur if during the contact between the two subjects (one of which is potentially infected) the distance between them was particularly close and if the contact duration was at least 15 minutes. In addition, to check the state of health of each individual in relation to the pandemic situation, it is essential to consider whether they have been given a vaccine and/or whether they have recently undergone a test to check for any positivity. \par
Specifically, in order to simulate the pandemic situation in the most realistic way possible and to optimally manage the available data that an information system directly connected to an app supported by the database will have to process, the following assumptions were taken into consideration:
  \begin{enumerate}[noitemsep]
    \item people can go to public places even without a green pass (therefore without a vaccine or a negative test carried out in the last 48 hours),
    \item data relating to public places are sent to the system by the manager of the public place itself,
    \item to record a greater number of relationships to be processed, while ensuring the consistency and meaningfulness of the stored data, it was decided to limit to an example study case in which the interactions present in the dataset are related to the single city of Milan and for a limited time interval, therefore:
  \begin{itemize}[noitemsep]
    \item[-] the tests dates, the meetings between people and the visits to public places took place from the 15\textsuperscript{th} of October to the 15\textsuperscript{th} of November, in addition, to test the queries more easily, there is a specific date, i.e. the 31\textsuperscript{st} of October, that expressely presents multiple recorded interactions,
    \item[-] vaccine administrations were all performed within the last year,
    \item[-] all public places are located in Milan,
    \item[-] meetings between people are geolocated within the city limits
  \end{itemize}
    \item with regard to the various connections that can exist between several people and the infections that can occur within the same family, it was preferred, for design purposes, to consider the concept of "same residential unit" (i.e. residence) rather than that of "family", since belonging to a given family unit does not necessarily imply a constant coexistence (e.g. workers who often travel for a job or off-site students) while a relationship of coexistence between several people, not necessarily related to each other, usually involves a close and inevitable contact,
    \item concerning to meetings between two or more people, it was assumed that any contact tracing devices/ apps interact with the system, communicating this information for each meeting: person1, person2, time at which the contact took place, geographical point in where the contact took place,
    \item a person is considered infected from the moment he undergoes a test and receives a positive result until he takes another test again but it is negative,
    \item in the event that a person undergoes a test and receives a positive result, all people met in the 15 days prior to the test will receive an alert notification on the app ensuring the privacy of the infected person is safeguarded,
    \item the possibility has also been envisaged in which a person already vaccinated may still be infected, in line with the cases that actually occurred
  \end{enumerate}
\clearpage
\section{ER diagram}
\paragraph{}
	\begin{center}
 		\includegraphics[width = 15 cm]{ER_diagram.png}
		\captionof{figure}{E-R Diagram}
	\end{center}
\par Starting from the considerations previously exposed regarding the implementation hypotheses, we have drawn an ER diagram (\textbf{Figure 1}) which includes 7 different entities and 4 many-to-many relationships described below in the logical model: \par
  \begin{itemize}[noitemsep]
   	\item[-]	\textbf{Address}(\underline{Address}, \underline{HouseNumber}, CAP, Latitude, Longitude, Municipality)
	\item[-]	\textbf{AuthorizedBody}\underline{(ID}, Department, Name, Type)
	\item[-]	\textbf{Certification}(\underline{ID})
	\item[-]	\textbf{HealthcarePersonnel}(\underline{CF}, Birthdate, Cellphone, Name, Sex, Surname)
	\item[-]	\textbf{Person}(\underline{CF}, Birthdate, Cellphone, Name, Sex, Surname)
	\item[-]	\textbf{Test}(\underline{ID}, Datetime, Result, Type)
	\item[-]	\textbf{Vaccination}(\underline{ID}, Datetime, Dose, Type)
\item[-]	\textbf{AttendsTest}(\underline{HealthcarePersonnel.CF}, \underline{Test.ID})	
	\item[-]	\textbf{AttendsVaccination}(\underline{HealthcarePersonnel.CF}, \underline{Vaccition.ID})
	\item[-]	\textbf{Contact}(\underline{Certification.ID}, \underline{Person.CF})
	\item[-]	\textbf{WorksIn}(\underline{AuthorizedBody.ID}, \underline{HealthcarePersonnel.CF})
  \end{itemize} \par
The \textbf{Person} entity describes each individual and their personal data, \textbf{HealthcarePersonnel} is a specialization of \textbf{Person} and includes all the people (doctors, nurses, pharmacists, etc.) who work (as indicated by the many-to-many \textbf{WorksIn} relationship) at an \textbf{AuthorizedBody}. Both the \textbf{Test} and \textbf{Vaccination} entities are linked to \textbf{HealthcarePersonnel} by the many-to-many \textbf{AttendsTest} and \textbf{AttendsVaccination} relationships, while the link with \textbf{AuthorizedBody} is given by the one-to-many \textbf{AdministersTest} and \textbf{AdministersVaccination}. Each \textbf{Person} can have one and only one (one-to-one relationship \textbf{Has}) \textbf{Certification}, that contains information regarding how many and which tests a person has undergone and whether or not he has received one or more doses of the vaccine, in fact, \textbf{Certification} is in a one-to-many relationship with both \textbf{Test} and \textbf{Vaccination}, through \textbf{IncludesTest} and \textbf{IncludesVaccination}, respectively. Furthermore, each \textbf{Certification} must also include for each \textbf{Person} a sort of "emergency contact" with its details as evidenced by the many-to-many \textbf{Contact} relationship. Finally, to save information relating to the geographical location of persons and authorized bodies, an \textbf{Address} entity was added with specific attributes, connected to \textbf{Person} and \textbf{AuthorizedBody} respectively by the one-to-many \textbf{LivesIn} and \textbf{In} relationships.
\section{Dataset description}
\paragraph{} One of the most critical parts of working with Big Data is managing large amounts of data collected in large datasets. To test and simulate the use of the database for contact tracing activities, some sample datasets were generated, saved in .csv format and imported into Neo4j through the command: \texttt{LOAD CSV FROM "file: ///file.csv" AS ...}. \par
Each dataset is divided into various fields that trace the structure of the tables expressed in the ER model, each one was generated randomly through Python scripts (you can find these ones into the folder \texttt{"db"}) and to experiment and perform at best the possible tests on the queries and commands that can be executed thanks to Neo4j the number of entries foreseen for each dataset is in the order of magnitude of the hundreds, as a whole, starting exclusively from the data loaded from the datasets, the database provides:
\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
Homes & 101 & Residence Relationship & 300 \\
\hline
People & 300 & Meetings & 726 \\
\hline
Public Places & 20 & Public Places Visits & 600 \\
\hline
Vaccine Types & 4 & Vaccinations & 526 \\
\hline
Test Types & 2 & Tests & 450\\
\hline
\textbf{TOTAL NODES} & \textbf{427} & \textbf{TOTAL RELATIONSHIPS} & \textbf{2602}\\
\hline
\end{tabular}
\end{center}
\section{Queries and Commands}
\paragraph{} The correct functioning of the information system involves the implementation of some essential commands and queries for the database in order to properly support the app and to ensure the right execution of searches among the data available for statistical or practical purposes. \par
\paragraph{} First of all you need to load the .csv files in two separate collections (authorizedBodies and certifications), you can find them following the path \texttt{"db/ab.csv"} and \texttt{"db/certification.csv"}
\paragraph{}When you are importing the data make sure to change the datatypes in:
\begin{itemize}
\item[•] All the dates/datetimes from String to Date
\item[•] In certifications test/vaccine.id\textunderscore authorized\textunderscore body from String to ObjectId
\item[•] In authorizedBodies \textunderscore id from String to ObjectId
\end{itemize}

\subsection{Queries}
\subsubsection{Find all the people with the Reinforced GreenPass}
\paragraph{} This query allows us to find all people in possession of a reinforced greenpass after the latest regulations, that is, all those who have been vaccinated in the last 9 months.
\begin{tcolorbox}[colback=green!5!white,colframe=green!75!black,title=QUERY]
\begin{verbatim}
db.certifications.find({
  "$and":[{"vaccination":{"$exists":true}},
  {"vaccination.datetime":{"$gte":new Date(
            ISODate().getTime() - 1000 * 3600 * 24 * 270)}},
  {"vaccination.datetime":{"$lte":new Date(
            ISODate().getTime())}}]
},{
  "person.name":1,
  "person.surname":1,
  "vaccination":1
})
\end{verbatim}
\end{tcolorbox}
\paragraph{} The output is given by: 
\begin{itemize}
\item[•] The ObjectId of the certification document
\item[•] The name and the surname of the person 
\item[•] The datetime of the vaccination
\end{itemize}
\begin{tcolorbox}[colback=red!5!white,colframe=red!75!black,title=OUTPUT]
\begin{verbatim}
{ _id: ObjectId("61af82fb2468d4592b37b6ee"),
  person: { name: 'Luca', surname: 'Colombo' },
  vaccination: 
   [ { datetime: 2021-09-07T17:31:42.000Z },
     { datetime: 2021-10-05T17:31:42.000Z } ] }
{ _id: ObjectId("61af82fb2468d4592b37b70e"),
  person: { name: 'Lorenzo Federico Giuseppe', 
            surname: 'Tomasi' },
  vaccination: [ { datetime: 2021-11-14T10:18:51.000Z } ] }
{ _id: ObjectId("61af82fb2468d4592b37b6e9"),
  person: { name: 'Vincenzo', surname: 'Maggiani' },
  vaccination: 
   [ { datetime: 2021-10-23T15:51:37.000Z },
     { datetime: 2021-11-20T16:51:37.000Z } ] }
        . . .
\end{verbatim}
\end{tcolorbox}
\clearpage
\subsubsection{Find the number of vaccinations ordered per month}
\paragraph{} This query allows us to retrieve some statistical data on the number of the vaccinations per month.
\begin{tcolorbox}[colback=green!5!white,colframe=green!75!black,title=QUERY]
\begin{verbatim}
db.certifications.aggregate(
    { $unwind : "$vaccination" }, 
    { $group: {
        _id: {month: { $month: "$vaccination.datetime" },
        year: { $year: "$vaccination.datetime" } },
        count: { $sum: 1 }
    }
    },{
      "$sort":{count:-1}
    }
)
\end{verbatim}
\end{tcolorbox}
\paragraph{} The output is given by: 
\begin{itemize}
\item[•] The count of the vaccinations
\item[•] The months and year
\begin{tcolorbox}[colback=red!5!white,colframe=red!75!black,title=OUTPUT]
\begin{verbatim}
{ _id: { month: 11, year: 2021 }, count: 41 }
{ _id: { month: 2, year: 2021 }, count: 36 }
{ _id: { month: 10, year: 2021 }, count: 36 }
{ _id: { month: 8, year: 2021 }, count: 36 }
{ _id: { month: 4, year: 2021 }, count: 35 }
{ _id: { month: 3, year: 2021 }, count: 32 }
{ _id: { month: 12, year: 2021 }, count: 29 }
{ _id: { month: 5, year: 2021 }, count: 27 }
{ _id: { month: 7, year: 2021 }, count: 27 }
{ _id: { month: 9, year: 2021 }, count: 26 }
{ _id: { month: 1, year: 2021 }, count: 22 }
{ _id: { month: 6, year: 2021 }, count: 14 }
\end{verbatim}
\end{tcolorbox}

\end{itemize}
\subsubsection{Find the age average of unvaccinated people}
\paragraph{} This query also allows us to get a statistical information about the age of the unvaccinated people
\begin{tcolorbox}[colback=green!5!white,colframe=green!75!black,title=QUERY]
\begin{verbatim}
db.certifications.aggregate([
    { $match : { 
      "person.birthdate" : { $exists : true},
      "vaccine":{"$exists":false}
    } },
    { $project : {"ageInMillis" : {$subtract : 
                 [new Date(), "$person.birthdate"] } } }, 
    { $project : {"age" : {$divide : 
                 ["$ageInMillis", 31558464000] }}},
    // take the floor of the previous number:
    { $project : {"age" : {$subtract : ["$age", 
                 {$mod : ["$age",1]}]}}},
    { $group : { _id : true, avgAge : { $avg : "$age"} } },
    { $project: { "avgAge": { $round: ["$avgAge", 2] }}}
])
\end{verbatim}
\end{tcolorbox}
\paragraph{} The output is given by: 
\begin{itemize}
\item[•] The age average
\end{itemize}
\begin{tcolorbox}[colback=red!5!white,colframe=red!75!black,title=OUTPUT]
\begin{verbatim}
{ _id: true, avgAge: 58.14 }
\end{verbatim}
\end{tcolorbox}

\subsubsection{Find all currently infected people}
\paragraph{} This query allows us to find people currently infected, i.e. those whose last test is positive.
\begin{tcolorbox}[colback=green!5!white,colframe=green!75!black,title=QUERY]
\begin{verbatim}
db.certifications.aggregate([
  {$addFields : {test : {$reduce : {
        input : "$test", 
        initialValue : {datetime : 
             new ISODate('2000-01-01T00:00:00')}, 
        in : {$cond: [{$gte : ["$$this.datetime", 
            "$$value.datetime"]},"$$this", "$$value"]}}
    }}},
     { $match:{"test.result":"Positive"}},
     {$project:{
           "person.name":"$person.name",
           "person.surname":"$person.surname",
           "person.codice_fiscale":"$person.codice_fiscale",
     }}
])
\end{verbatim}
\end{tcolorbox}
\paragraph{} The output is given by: 
\begin{itemize}
\item[•] The ObjectId of the certification document
\item[•] The name and surname of the person
\item[•] The CF of the person
\end{itemize}
\begin{tcolorbox}[colback=red!5!white,colframe=red!75!black,title=OUTPUT]
\begin{verbatim}
{ _id: ObjectId("61af82fb2468d4592b37b71e"),
  person: 
   { name: 'Adele',
     surname: 'Mantovani',
     codice_fiscale: 'MNTDLA62D60C059I' } }
{ _id: ObjectId("61af82fb2468d4592b37b71b"),
  person: 
   { name: 'Ferruccio',
     surname: 'Meloni',
     codice_fiscale: 'MLNFRC61D17B246A' } }
{ _id: ObjectId("61af82fb2468d4592b37b7ab"),
  person: 
   { name: 'Riccardo',
     surname: 'Brumat',
     codice_fiscale: 'BRMRCR65T22F356R' } }
\end{verbatim}
\end{tcolorbox}


\subsubsection{Find the number of tests per authorized body (JOIN) }
\paragraph{} This query allows us to find the number of tests that each authorized body did, in this query we use the JOIN of the two document in order to retrieve the name and the type of the authorized body starting from the id in the certification document. 
\paragraph{}MongoDB is not optimized to perform this type of operation like relational databases, so the query is optimized to perform the join on as few elements as possible grouping the tests in pipeline before the join.

\begin{tcolorbox}[colback=green!5!white,colframe=green!75!black,title=QUERY]
\begin{verbatim}
db.certifications.aggregate([
  { $unwind : "$test" },
  {$group:{
    _id:"$test.id_authorized_body",
    count:{$sum:1}
  }},
  {
    "$lookup": {
        "from": "authorizedBodies",
       "localField": "_id",
        "foreignField": "_id",
        "as": "authorizedBodyInfo"
        }
  },
  {
    "$project":{_id:0,count:1,
    "authorizedBodyInfo.name":"$authorizedBodyInfo.name",
    "authorizedBodyInfo.type":"$authorizedBodyInfo.type"
    }
  }
  ])
\end{verbatim}
\end{tcolorbox}

\paragraph{} The output is given by: 
\begin{itemize}
\item[•] The count of the tests done
\item[•] The name of the authorized body
\item[•] The type of the authorized body
\end{itemize}

\begin{tcolorbox}[colback=red!5!white,colframe=red!75!black,title=OUTPUT]
\begin{verbatim}
{ count: 17,
  authorizedBodyInfo: [ { name: [ 'Policlinico' ],
                          type: [ 'Hospital' ] } ] }
{ count: 21,
  authorizedBodyInfo: [ { name: [ 'Auxologico San Luca' ], 
                          type: [ 'Hospital' ] } ] }
{ count: 25,
  authorizedBodyInfo: [ { name: [ 'San Raffaele' ],
                          type: [ 'Hospital' ] } ] }
{ count: 19,
  authorizedBodyInfo: [ { name: [ 'San Paolo' ], 
                          type: [ 'Hospital' ] } ] }
{ count: 26,
  authorizedBodyInfo: [ { name: [ 'San Giuseppe' ], 
                          type: [ 'Hospital' ] } ] }
{ count: 15,
  authorizedBodyInfo: [ { name: [ 'Ospedale Fiera' ], 
                          type: [ 'Hospital' ] } ] }
        . . .
\end{verbatim}
\end{tcolorbox}


\subsection{Commands}
\subsubsection{Insert a new Authorized Body (CREATE)}
\paragraph{} In this command we insert in the authorizedBodies collection a new document.

\begin{tcolorbox}[colback=orange!5!white,colframe=orange!75!black,title=COMMAND]
\begin{verbatim}
db.authorizedBodies.insertOne({
  "address":{
    "address":"Via Roma",
    "cap":"24030",
    "geopoint":"45.0000 9.0000",
    "house":"13b",
    "municipality":"Bergamo",
  },
  "department":"covid test",
  "name":"Farmacia Comunale",
  "type":"pharmacy",
  "healthcarePersonnel":[
    {
      "cellphone":"+393476574382",
      "codice_fiscale":"DNTHGB87P15G764J",
      "name":"Carlo",
      "role":"pharmacist",
      "surname":"Merlutti",
    }
  ]
})
\end{verbatim}
\end{tcolorbox}

\subsubsection{Insert a test in a Certification (UPDATE) }
\paragraph{} In this command we add to a given certification (via ObjectId) a new test as a subdocument in the ArrayList field test.
\begin{tcolorbox}[colback=orange!5!white,colframe=orange!75!black,title=COMMAND]
\begin{verbatim}
db.certifications.updateOne({
  "_id":ObjectId('61af82fb2468d4592b37b70e')
},{
  "$push":{
    "test":{
      "$each":[{
        "datetime":ISODate('2021-12-08T16:20:00'),
        "healthcarePersonnel":{
          "codice_fiscale":"PLCLRT48C02C224Y",
          "name":"Alberto Christian",
          "surname":"Paolucci"
        },
        "id_authorized_body":
                ObjectId('61acd3e25ca7e964a122def1'),
        "result":"Positive",
        "type":"Molecular"
      }]
    }
  }
})
\end{verbatim}
\end{tcolorbox}


\subsubsection{Delete all the Authorized Bodies that test and are pharmacies (DELETE)}
\paragraph{} In this command we simulate a change of regulations where the pharmacies can no longer test people and therefore we delete this kind of authorized body from the collection.
\begin{tcolorbox}[colback=orange!5!white,colframe=orange!75!black,title=COMMAND]
\begin{verbatim}
db.authorizedBodies.deleteMany({
  "$and":[
    {"type":"pharmacy"},
    {"department":"covid test"}]
})

\end{verbatim}
\end{tcolorbox}
\clearpage
\section{UI description \& User Guide}
\subsection{UI description}
\paragraph{}The design of the information system ended with the development of \emph{ContagionShield}, an application connected to the database with a simple GUI that is very intuitive and easy to use. The UI was created with the Python programming language by means of the libraries: \emph{PySimpleGUI} for the creation of the graphical interface, \emph{Py2neo} to work with Neo4j through the syntax offered by Python and \emph{pandas} to manage the analysis and manipulation of data, you can find these ones into the folder \texttt{"contagionshield"}. \par

As you can see from \textbf{Figure 3}, the main screen of the application is divided into two sections: one on the left that allows you to create customizable queries by choosing date, place, time interval and whether to display the vaccinated, non-vaccinated or with negative test, in \textbf{Figure 4} there is an example query with the results obtained; the other side section on the right (\textbf{Figure 5}) presents some predefined queries, some of them follow the ones specified and described in Chapter 5 of the report. \par

\pagebreak
Finally, as shown in \textbf{Figure 6}, it is possible to execute some of the commands already presented in Chapter 5 by reaching the appropriate section of the application by means of the \texttt{"Commands"} button in the lower left corner of the main screen. The executable commands allow you to create new meetings between several people by indicating their social security numbers, the date and time, create new visits to public places by specifying who went to a given place and when and in the end you can also delete all the visits to public places recorded in the last year. \par

\subsection{User Guide}
\paragraph{}
In order to run \emph{ContagionShield} it is necessary to verify some requirements and to perform some actions:
\begin{itemize}[noitemsep]
   \item[-] At first you have to check if you have the right Python version installed by using the command: \texttt{python --version}, if not you could download it from the official website: https://www.python.org/ 
   \item[-] Then make sure your local database is at \texttt{localhost:7687} and that it has \texttt{"smbud"} as password
   \item[-] Install the required packages (in the "contagionshield" folder): \texttt{pip install -r requirements.txt}
   \item[-] Finally make it run by navigating to the folder where you have been saved the materials, then into \texttt{"contagionshield"} folder and run: \texttt{python contagionshield.py}
   \item[-] From there you can execute queries about the collected data
\end{itemize}
\newpage
\section{References \& Sources}
  \begin{thebibliography}{9}
    \bibitem{} Course Slides
    \bibitem{} https://pysimplegui.readthedocs.io/en/latest/call%20reference/
    \bibitem{} https://py2neo.org/
    \bibitem{} https://neo4j.com/docs/cypher-manual/current/
    \bibitem{} https://neo4j.com/developer/python/
    \bibitem{} http://iniball.altervista.org/Software/ProgER
    \bibitem{} https://neo4j.com/developer/cypher/
    \bibitem{} https://pandas.pydata.org/docs/
  \end{thebibliography}
\end{document}
